import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import {
  Keypair,
  PublicKey,
  SystemProgram,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import { expect } from "chai";

// The IDL type will be generated by Anchor build. We reference it generically here.
// When `anchor build` runs, it produces target/types/solagent.ts with the `Solagent` type.
import type { Solagent } from "../target/types/solagent";

describe("solagent", () => {
  // ----------------------------------------------------------------
  // Provider & program setup
  // ----------------------------------------------------------------
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Solagent as Program<Solagent>;
  const authority = provider.wallet;

  // ----------------------------------------------------------------
  // Helper: derive PDAs
  // ----------------------------------------------------------------
  function findProtocolPDA(): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from("protocol")],
      program.programId
    );
  }

  function findAgentPDA(authorityKey: PublicKey): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from("agent"), authorityKey.toBuffer()],
      program.programId
    );
  }

  function findVaultPDA(agentKey: PublicKey): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from("vault"), agentKey.toBuffer()],
      program.programId
    );
  }

  function findFeedbackPDA(
    fromAgentKey: PublicKey,
    toAgentKey: PublicKey
  ): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from("feedback"), fromAgentKey.toBuffer(), toAgentKey.toBuffer()],
      program.programId
    );
  }

  function findServicePDA(
    agentKey: PublicKey,
    serviceId: string
  ): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from("service"), agentKey.toBuffer(), Buffer.from(serviceId)],
      program.programId
    );
  }

  function findPaymentPDA(
    payerAgentKey: PublicKey,
    serviceKey: PublicKey,
    orderIndex: number
  ): [PublicKey, number] {
    const buf = Buffer.alloc(8);
    buf.writeBigUInt64LE(BigInt(orderIndex));
    return PublicKey.findProgramAddressSync(
      [
        Buffer.from("payment"),
        payerAgentKey.toBuffer(),
        serviceKey.toBuffer(),
        buf,
      ],
      program.programId
    );
  }

  function findEscrowPDA(paymentKey: PublicKey): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from("escrow"), paymentKey.toBuffer()],
      program.programId
    );
  }

  function findStreamPDA(
    payerAgentKey: PublicKey,
    receiverAgentKey: PublicKey
  ): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [
        Buffer.from("stream"),
        payerAgentKey.toBuffer(),
        receiverAgentKey.toBuffer(),
      ],
      program.programId
    );
  }

  function findStreamVaultPDA(streamKey: PublicKey): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from("stream_vault"), streamKey.toBuffer()],
      program.programId
    );
  }

  // ----------------------------------------------------------------
  // Helper: airdrop SOL to a keypair
  // ----------------------------------------------------------------
  async function airdrop(pubkey: PublicKey, sol: number = 10) {
    const sig = await provider.connection.requestAirdrop(
      pubkey,
      sol * LAMPORTS_PER_SOL
    );
    const latestBlockhash = await provider.connection.getLatestBlockhash();
    await provider.connection.confirmTransaction({
      signature: sig,
      ...latestBlockhash,
    });
  }

  // ----------------------------------------------------------------
  // Helper: create a funded keypair and return it
  // ----------------------------------------------------------------
  async function createFundedKeypair(sol: number = 10): Promise<Keypair> {
    const kp = Keypair.generate();
    await airdrop(kp.publicKey, sol);
    return kp;
  }

  // ----------------------------------------------------------------
  // Helper: register an agent for a given keypair, returns agent PDA
  // ----------------------------------------------------------------
  async function registerAgentHelper(
    kp: Keypair,
    name: string = "TestAgent",
    description: string = "A test agent",
    capabilities: string[] = ["inference"],
    endpoint: string = "https://api.testagent.ai"
  ): Promise<PublicKey> {
    const [agentPDA] = findAgentPDA(kp.publicKey);
    await program.methods
      .registerAgent(name, description, capabilities, endpoint)
      .accounts({
        agent: agentPDA,
        authority: kp.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([kp])
      .rpc();
    return agentPDA;
  }

  // ----------------------------------------------------------------
  // Shared state across tests (populated sequentially)
  // ----------------------------------------------------------------
  let protocolPDA: PublicKey;
  let agentAKeypair: Keypair;
  let agentBKeypair: Keypair;
  let agentAPDA: PublicKey;
  let agentBPDA: PublicKey;
  let servicePDA: PublicKey;
  const SERVICE_ID = "gpt4-summarizer";

  // ================================================================
  // 1. INITIALIZE PROTOCOL
  // ================================================================
  describe("initialize_protocol", () => {
    it("initializes the protocol state", async () => {
      const [pda] = findProtocolPDA();
      protocolPDA = pda;

      await program.methods
        .initializeProtocol()
        .accounts({
          protocol: protocolPDA,
          authority: authority.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      const proto = await program.account.protocol.fetch(protocolPDA);
      expect(proto.authority.toBase58()).to.equal(
        authority.publicKey.toBase58()
      );
      expect(proto.totalAgents.toNumber()).to.equal(0);
      expect(proto.totalServices.toNumber()).to.equal(0);
      expect(proto.totalPayments.toNumber()).to.equal(0);
      expect(proto.totalVolume.toNumber()).to.equal(0);
      expect(proto.totalStaked.toNumber()).to.equal(0);
      expect(proto.feeBps).to.equal(10);
      expect(proto.treasury.toBase58()).to.equal(
        authority.publicKey.toBase58()
      );
    });

    it("fails when trying to initialize protocol again (duplicate PDA)", async () => {
      try {
        await program.methods
          .initializeProtocol()
          .accounts({
            protocol: protocolPDA,
            authority: authority.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .rpc();
        expect.fail("Should have thrown an error for duplicate initialization");
      } catch (err: any) {
        // Anchor init constraint will fail because account already exists
        expect(err).to.exist;
      }
    });
  });

  // ================================================================
  // 2. REGISTER AGENT
  // ================================================================
  describe("register_agent", () => {
    before(async () => {
      agentAKeypair = await createFundedKeypair();
      agentBKeypair = await createFundedKeypair();
    });

    it("registers agent A successfully", async () => {
      const [pda] = findAgentPDA(agentAKeypair.publicKey);
      agentAPDA = pda;

      await program.methods
        .registerAgent(
          "AgentAlpha",
          "Advanced AI agent for NLP tasks",
          ["inference", "summarization", "translation"],
          "https://alpha.agent.ai/api"
        )
        .accounts({
          agent: agentAPDA,
          authority: agentAKeypair.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([agentAKeypair])
        .rpc();

      const agent = await program.account.agent.fetch(agentAPDA);
      expect(agent.authority.toBase58()).to.equal(
        agentAKeypair.publicKey.toBase58()
      );
      expect(agent.name).to.equal("AgentAlpha");
      expect(agent.description).to.equal("Advanced AI agent for NLP tasks");
      expect(agent.capabilities).to.deep.equal([
        "inference",
        "summarization",
        "translation",
      ]);
      expect(agent.endpoint).to.equal("https://alpha.agent.ai/api");
      expect(agent.reputationScore.toNumber()).to.equal(0);
      expect(agent.totalStaked.toNumber()).to.equal(0);
      expect(agent.totalEarned.toNumber()).to.equal(0);
      expect(agent.totalSpent.toNumber()).to.equal(0);
      expect(agent.servicesCompleted.toNumber()).to.equal(0);
      expect(agent.servicesRequested.toNumber()).to.equal(0);
      expect(agent.feedbacksReceived.toNumber()).to.equal(0);
      expect(agent.isActive).to.be.true;
    });

    it("registers agent B successfully", async () => {
      const [pda] = findAgentPDA(agentBKeypair.publicKey);
      agentBPDA = pda;

      await program.methods
        .registerAgent(
          "AgentBeta",
          "Image generation specialist",
          ["image-gen", "upscaling"],
          "https://beta.agent.ai/api"
        )
        .accounts({
          agent: agentBPDA,
          authority: agentBKeypair.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([agentBKeypair])
        .rpc();

      const agent = await program.account.agent.fetch(agentBPDA);
      expect(agent.name).to.equal("AgentBeta");
      expect(agent.capabilities).to.deep.equal(["image-gen", "upscaling"]);
    });

    it("fails to register a second agent for the same authority (duplicate PDA)", async () => {
      try {
        const [pda] = findAgentPDA(agentAKeypair.publicKey);
        await program.methods
          .registerAgent(
            "Duplicate",
            "Should fail",
            ["test"],
            "https://fail.ai"
          )
          .accounts({
            agent: pda,
            authority: agentAKeypair.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([agentAKeypair])
          .rpc();
        expect.fail("Should have thrown - agent already exists for authority");
      } catch (err: any) {
        expect(err).to.exist;
      }
    });

    it("fails when name exceeds 32 characters", async () => {
      const badKp = await createFundedKeypair();
      const [pda] = findAgentPDA(badKp.publicKey);
      try {
        await program.methods
          .registerAgent(
            "A".repeat(33), // 33 chars > 32
            "Valid description",
            ["test"],
            "https://x.ai"
          )
          .accounts({
            agent: pda,
            authority: badKp.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([badKp])
          .rpc();
        expect.fail("Should have thrown NameTooLong");
      } catch (err: any) {
        expect(err.toString()).to.include("NameTooLong");
      }
    });

    it("fails when description exceeds 256 characters", async () => {
      const badKp = await createFundedKeypair();
      const [pda] = findAgentPDA(badKp.publicKey);
      try {
        await program.methods
          .registerAgent(
            "ValidName",
            "D".repeat(257), // 257 chars > 256
            ["test"],
            "https://x.ai"
          )
          .accounts({
            agent: pda,
            authority: badKp.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([badKp])
          .rpc();
        expect.fail("Should have thrown DescriptionTooLong");
      } catch (err: any) {
        expect(err.toString()).to.include("DescriptionTooLong");
      }
    });

    it("fails when too many capabilities (> 10)", async () => {
      const badKp = await createFundedKeypair();
      const [pda] = findAgentPDA(badKp.publicKey);
      const tooMany = Array.from({ length: 11 }, (_, i) => `cap${i}`);
      try {
        await program.methods
          .registerAgent("Valid", "Valid", tooMany, "https://x.ai")
          .accounts({
            agent: pda,
            authority: badKp.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([badKp])
          .rpc();
        expect.fail("Should have thrown TooManyCapabilities");
      } catch (err: any) {
        expect(err.toString()).to.include("TooManyCapabilities");
      }
    });
  });

  // ================================================================
  // 3. STAKE REPUTATION
  // ================================================================
  describe("stake_reputation", () => {
    it("stakes SOL and updates reputation score", async () => {
      const [vaultPDA] = findVaultPDA(agentAPDA);
      const stakeAmount = new anchor.BN(1 * LAMPORTS_PER_SOL); // 1 SOL

      await program.methods
        .stakeReputation(stakeAmount)
        .accounts({
          agent: agentAPDA,
          vault: vaultPDA,
          authority: agentAKeypair.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([agentAKeypair])
        .rpc();

      const agent = await program.account.agent.fetch(agentAPDA);
      expect(agent.totalStaked.toNumber()).to.equal(1 * LAMPORTS_PER_SOL);
      // For 1 SOL: log2(1.0) * 10 + 50 = 0 + 50 = 50, feedbacks=0, completed=0
      expect(agent.reputationScore.toNumber()).to.equal(50);
    });

    it("staking additional SOL increases reputation with diminishing returns", async () => {
      const [vaultPDA] = findVaultPDA(agentAPDA);
      const stakeAmount = new anchor.BN(3 * LAMPORTS_PER_SOL); // 3 more SOL (total 4)

      await program.methods
        .stakeReputation(stakeAmount)
        .accounts({
          agent: agentAPDA,
          vault: vaultPDA,
          authority: agentAKeypair.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([agentAKeypair])
        .rpc();

      const agent = await program.account.agent.fetch(agentAPDA);
      expect(agent.totalStaked.toNumber()).to.equal(4 * LAMPORTS_PER_SOL);
      // For 4 SOL: log2(4.0) * 10 + 50 = 20 + 50 = 70
      expect(agent.reputationScore.toNumber()).to.equal(70);
    });

    it("fails when staking zero amount", async () => {
      const [vaultPDA] = findVaultPDA(agentAPDA);
      try {
        await program.methods
          .stakeReputation(new anchor.BN(0))
          .accounts({
            agent: agentAPDA,
            vault: vaultPDA,
            authority: agentAKeypair.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([agentAKeypair])
          .rpc();
        expect.fail("Should have thrown ZeroAmount");
      } catch (err: any) {
        expect(err.toString()).to.include("ZeroAmount");
      }
    });

    it("fails when non-authority tries to stake", async () => {
      const randomKp = await createFundedKeypair();
      const [vaultPDA] = findVaultPDA(agentAPDA);
      try {
        await program.methods
          .stakeReputation(new anchor.BN(LAMPORTS_PER_SOL))
          .accounts({
            agent: agentAPDA,
            vault: vaultPDA,
            authority: randomKp.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([randomKp])
          .rpc();
        expect.fail("Should have thrown - wrong authority");
      } catch (err: any) {
        // has_one = authority constraint fails, or seeds mismatch
        expect(err).to.exist;
      }
    });
  });

  // ================================================================
  // 4. SUBMIT FEEDBACK
  // ================================================================
  describe("submit_feedback", () => {
    it("agent A submits feedback to agent B", async () => {
      const [feedbackPDA] = findFeedbackPDA(agentAPDA, agentBPDA);

      await program.methods
        .submitFeedback(5, "Excellent image generation quality!")
        .accounts({
          feedback: feedbackPDA,
          fromAgent: agentAPDA,
          toAgent: agentBPDA,
          authority: agentAKeypair.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([agentAKeypair])
        .rpc();

      const feedback = await program.account.feedback.fetch(feedbackPDA);
      expect(feedback.fromAgent.toBase58()).to.equal(agentAPDA.toBase58());
      expect(feedback.toAgent.toBase58()).to.equal(agentBPDA.toBase58());
      expect(feedback.rating).to.equal(5);
      expect(feedback.comment).to.equal(
        "Excellent image generation quality!"
      );

      // Check that agent B's reputation was updated
      const agentB = await program.account.agent.fetch(agentBPDA);
      expect(agentB.feedbacksReceived.toNumber()).to.equal(1);
      // Agent B has no stake, so base_rep = 0; feedback_bonus = 1*2 = 2; completion = 0
      expect(agentB.reputationScore.toNumber()).to.equal(2);
    });

    it("fails to submit duplicate feedback (same from->to pair)", async () => {
      const [feedbackPDA] = findFeedbackPDA(agentAPDA, agentBPDA);
      try {
        await program.methods
          .submitFeedback(4, "Second feedback")
          .accounts({
            feedback: feedbackPDA,
            fromAgent: agentAPDA,
            toAgent: agentBPDA,
            authority: agentAKeypair.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([agentAKeypair])
          .rpc();
        expect.fail("Should have thrown - feedback PDA already exists");
      } catch (err: any) {
        expect(err).to.exist;
      }
    });

    it("fails with invalid rating (0)", async () => {
      const freshKp = await createFundedKeypair();
      const freshAgentPDA = await registerAgentHelper(freshKp, "Rater0");
      const [feedbackPDA] = findFeedbackPDA(freshAgentPDA, agentAPDA);

      try {
        await program.methods
          .submitFeedback(0, "Bad rating value")
          .accounts({
            feedback: feedbackPDA,
            fromAgent: freshAgentPDA,
            toAgent: agentAPDA,
            authority: freshKp.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([freshKp])
          .rpc();
        expect.fail("Should have thrown InvalidRating");
      } catch (err: any) {
        expect(err.toString()).to.include("InvalidRating");
      }
    });

    it("fails with invalid rating (6)", async () => {
      const freshKp = await createFundedKeypair();
      const freshAgentPDA = await registerAgentHelper(freshKp, "Rater6");
      const [feedbackPDA] = findFeedbackPDA(freshAgentPDA, agentAPDA);

      try {
        await program.methods
          .submitFeedback(6, "Bad rating value")
          .accounts({
            feedback: feedbackPDA,
            fromAgent: freshAgentPDA,
            toAgent: agentAPDA,
            authority: freshKp.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([freshKp])
          .rpc();
        expect.fail("Should have thrown InvalidRating");
      } catch (err: any) {
        expect(err.toString()).to.include("InvalidRating");
      }
    });

    it("fails when comment exceeds 256 characters", async () => {
      const freshKp = await createFundedKeypair();
      const freshAgentPDA = await registerAgentHelper(freshKp, "LongComment");
      const [feedbackPDA] = findFeedbackPDA(freshAgentPDA, agentAPDA);

      try {
        await program.methods
          .submitFeedback(3, "X".repeat(257))
          .accounts({
            feedback: feedbackPDA,
            fromAgent: freshAgentPDA,
            toAgent: agentAPDA,
            authority: freshKp.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([freshKp])
          .rpc();
        expect.fail("Should have thrown CommentTooLong");
      } catch (err: any) {
        expect(err.toString()).to.include("CommentTooLong");
      }
    });
  });

  // ================================================================
  // 5. CREATE SERVICE
  // ================================================================
  describe("create_service", () => {
    it("creates a service on the marketplace", async () => {
      const [svcPDA] = findServicePDA(agentAPDA, SERVICE_ID);
      servicePDA = svcPDA;

      await program.methods
        .createService(
          SERVICE_ID,
          "GPT-4 Summarizer",
          "Summarizes any text using GPT-4 Turbo",
          new anchor.BN(0.01 * LAMPORTS_PER_SOL), // 0.01 SOL per request
          { perRequest: {} }, // PriceModel::PerRequest
          ["nlp", "summarization", "gpt4"]
        )
        .accounts({
          service: servicePDA,
          agent: agentAPDA,
          authority: agentAKeypair.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([agentAKeypair])
        .rpc();

      const svc = await program.account.service.fetch(servicePDA);
      expect(svc.provider.toBase58()).to.equal(agentAPDA.toBase58());
      expect(svc.authority.toBase58()).to.equal(
        agentAKeypair.publicKey.toBase58()
      );
      expect(svc.serviceId).to.equal(SERVICE_ID);
      expect(svc.title).to.equal("GPT-4 Summarizer");
      expect(svc.description).to.equal(
        "Summarizes any text using GPT-4 Turbo"
      );
      expect(svc.priceLamports.toNumber()).to.equal(0.01 * LAMPORTS_PER_SOL);
      expect(svc.tags).to.deep.equal(["nlp", "summarization", "gpt4"]);
      expect(svc.totalOrders.toNumber()).to.equal(0);
      expect(svc.totalRevenue.toNumber()).to.equal(0);
      expect(svc.isActive).to.be.true;
    });

    it("fails with duplicate service_id for same agent", async () => {
      try {
        await program.methods
          .createService(
            SERVICE_ID,
            "Duplicate",
            "Should fail",
            new anchor.BN(100),
            { fixed: {} },
            ["dup"]
          )
          .accounts({
            service: servicePDA,
            agent: agentAPDA,
            authority: agentAKeypair.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([agentAKeypair])
          .rpc();
        expect.fail("Should have thrown - service PDA already exists");
      } catch (err: any) {
        expect(err).to.exist;
      }
    });

    it("fails when title exceeds 64 characters", async () => {
      const [svcPDA] = findServicePDA(agentAPDA, "long-title-svc");
      try {
        await program.methods
          .createService(
            "long-title-svc",
            "T".repeat(65),
            "Valid desc",
            new anchor.BN(100),
            { fixed: {} },
            ["test"]
          )
          .accounts({
            service: svcPDA,
            agent: agentAPDA,
            authority: agentAKeypair.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([agentAKeypair])
          .rpc();
        expect.fail("Should have thrown TitleTooLong");
      } catch (err: any) {
        expect(err.toString()).to.include("TitleTooLong");
      }
    });

    it("fails when too many tags (> 5)", async () => {
      const [svcPDA] = findServicePDA(agentAPDA, "many-tags-svc");
      try {
        await program.methods
          .createService(
            "many-tags-svc",
            "Valid Title",
            "Valid desc",
            new anchor.BN(100),
            { fixed: {} },
            ["a", "b", "c", "d", "e", "f"] // 6 tags > 5
          )
          .accounts({
            service: svcPDA,
            agent: agentAPDA,
            authority: agentAKeypair.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([agentAKeypair])
          .rpc();
        expect.fail("Should have thrown TooManyTags");
      } catch (err: any) {
        expect(err.toString()).to.include("TooManyTags");
      }
    });

    it("different agent can create service with same service_id", async () => {
      const [svcPDA] = findServicePDA(agentBPDA, SERVICE_ID);
      await program.methods
        .createService(
          SERVICE_ID,
          "Beta Summarizer",
          "Agent B also summarizes",
          new anchor.BN(0.02 * LAMPORTS_PER_SOL),
          { perRequest: {} },
          ["nlp"]
        )
        .accounts({
          service: svcPDA,
          agent: agentBPDA,
          authority: agentBKeypair.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([agentBKeypair])
        .rpc();

      const svc = await program.account.service.fetch(svcPDA);
      expect(svc.provider.toBase58()).to.equal(agentBPDA.toBase58());
      expect(svc.title).to.equal("Beta Summarizer");
    });

    it("creates services with all price model variants", async () => {
      const priceModels = [
        { fixed: {} },
        { perSecond: {} },
        { perToken: {} },
        { auction: {} },
      ];

      for (let i = 0; i < priceModels.length; i++) {
        const svcId = `price-model-${i}`;
        const [svcPDA] = findServicePDA(agentAPDA, svcId);
        await program.methods
          .createService(
            svcId,
            `Service Model ${i}`,
            "Testing price models",
            new anchor.BN(1000),
            priceModels[i] as any,
            ["test"]
          )
          .accounts({
            service: svcPDA,
            agent: agentAPDA,
            authority: agentAKeypair.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([agentAKeypair])
          .rpc();

        const svc = await program.account.service.fetch(svcPDA);
        expect(svc.isActive).to.be.true;
      }
    });
  });

  // ================================================================
  // 6. PAY FOR SERVICE (Escrow)
  // ================================================================
  describe("pay_for_service", () => {
    const paymentAmount = new anchor.BN(0.05 * LAMPORTS_PER_SOL);
    let paymentPDA: PublicKey;
    let escrowPDA: PublicKey;

    it("agent B pays agent A's service (funds go to escrow)", async () => {
      // Before: service.total_orders == 0 so we use 0 as the index
      const svc = await program.account.service.fetch(servicePDA);
      const currentOrders = svc.totalOrders.toNumber();

      const [pmtPDA] = findPaymentPDA(agentBPDA, servicePDA, currentOrders);
      paymentPDA = pmtPDA;
      const [escPDA] = findEscrowPDA(paymentPDA);
      escrowPDA = escPDA;

      const payerBalBefore = await provider.connection.getBalance(
        agentBKeypair.publicKey
      );

      await program.methods
        .payForService(
          paymentAmount,
          "Summarize my 10-page document",
          ["deliver within 60s", "min 500 words"],
          new anchor.BN(3600) // 1 hour timeout
        )
        .accounts({
          payment: paymentPDA,
          escrow: escrowPDA,
          payerAgent: agentBPDA,
          receiverAgent: agentAPDA,
          service: servicePDA,
          payerAuthority: agentBKeypair.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([agentBKeypair])
        .rpc();

      // Verify payment account
      const payment = await program.account.payment.fetch(paymentPDA);
      expect(payment.payer.toBase58()).to.equal(agentBPDA.toBase58());
      expect(payment.receiver.toBase58()).to.equal(agentAPDA.toBase58());
      expect(payment.service.toBase58()).to.equal(servicePDA.toBase58());
      expect(payment.amount.toNumber()).to.equal(paymentAmount.toNumber());
      expect(payment.intent).to.equal("Summarize my 10-page document");
      expect(payment.conditions).to.deep.equal([
        "deliver within 60s",
        "min 500 words",
      ]);
      expect(payment.status).to.deep.equal({ escrowed: {} });
      expect(payment.completedAt.toNumber()).to.equal(0);

      // Verify escrow received the funds
      const escrowBal = await provider.connection.getBalance(escrowPDA);
      expect(escrowBal).to.be.gte(paymentAmount.toNumber());

      // Verify service order count incremented
      const svcAfter = await program.account.service.fetch(servicePDA);
      expect(svcAfter.totalOrders.toNumber()).to.equal(currentOrders + 1);

      // Verify payer agent stats updated
      const payerAgent = await program.account.agent.fetch(agentBPDA);
      expect(payerAgent.servicesRequested.toNumber()).to.equal(1);
      expect(payerAgent.totalSpent.toNumber()).to.equal(
        paymentAmount.toNumber()
      );
    });

    it("fails when payment amount is zero", async () => {
      const svc = await program.account.service.fetch(servicePDA);
      const [pmtPDA] = findPaymentPDA(
        agentBPDA,
        servicePDA,
        svc.totalOrders.toNumber()
      );
      const [escPDA] = findEscrowPDA(pmtPDA);

      try {
        await program.methods
          .payForService(
            new anchor.BN(0),
            "Zero pay",
            [],
            new anchor.BN(3600)
          )
          .accounts({
            payment: pmtPDA,
            escrow: escPDA,
            payerAgent: agentBPDA,
            receiverAgent: agentAPDA,
            service: servicePDA,
            payerAuthority: agentBKeypair.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([agentBKeypair])
          .rpc();
        expect.fail("Should have thrown ZeroAmount");
      } catch (err: any) {
        expect(err.toString()).to.include("ZeroAmount");
      }
    });

    it("fails when intent exceeds 256 characters", async () => {
      const svc = await program.account.service.fetch(servicePDA);
      const [pmtPDA] = findPaymentPDA(
        agentBPDA,
        servicePDA,
        svc.totalOrders.toNumber()
      );
      const [escPDA] = findEscrowPDA(pmtPDA);

      try {
        await program.methods
          .payForService(
            new anchor.BN(1000),
            "I".repeat(257),
            [],
            new anchor.BN(3600)
          )
          .accounts({
            payment: pmtPDA,
            escrow: escPDA,
            payerAgent: agentBPDA,
            receiverAgent: agentAPDA,
            service: servicePDA,
            payerAuthority: agentBKeypair.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([agentBKeypair])
          .rpc();
        expect.fail("Should have thrown IntentTooLong");
      } catch (err: any) {
        expect(err.toString()).to.include("IntentTooLong");
      }
    });

    // Store paymentPDA/escrowPDA for release_payment tests
    after(() => {
      // Make these available to subsequent describe blocks via closure
      (describe as any)._paymentPDA = paymentPDA;
      (describe as any)._escrowPDA = escrowPDA;
    });
  });

  // ================================================================
  // 7. RELEASE PAYMENT (happy path escrow flow)
  // ================================================================
  describe("release_payment", () => {
    let paymentPDA: PublicKey;
    let escrowPDA: PublicKey;

    before(() => {
      paymentPDA = (describe as any)._paymentPDA;
      escrowPDA = (describe as any)._escrowPDA;
    });

    it("payer releases escrowed payment to receiver after service delivery", async () => {
      const receiverBalBefore = await provider.connection.getBalance(
        agentAKeypair.publicKey
      );
      const payment = await program.account.payment.fetch(paymentPDA);
      const amount = payment.amount.toNumber();

      await program.methods
        .releasePayment()
        .accounts({
          payment: paymentPDA,
          escrow: escrowPDA,
          payerAgent: agentBPDA,
          receiverAgent: agentAPDA,
          service: servicePDA,
          receiverAuthority: agentAKeypair.publicKey,
          authority: agentBKeypair.publicKey,
        })
        .signers([agentBKeypair])
        .rpc();

      // Verify payment status changed to Released
      const paymentAfter = await program.account.payment.fetch(paymentPDA);
      expect(paymentAfter.status).to.deep.equal({ released: {} });
      expect(paymentAfter.completedAt.toNumber()).to.be.greaterThan(0);

      // Verify receiver got the funds
      const receiverBalAfter = await provider.connection.getBalance(
        agentAKeypair.publicKey
      );
      expect(receiverBalAfter - receiverBalBefore).to.equal(amount);

      // Verify receiver agent stats
      const receiverAgent = await program.account.agent.fetch(agentAPDA);
      expect(receiverAgent.servicesCompleted.toNumber()).to.equal(1);
      expect(receiverAgent.totalEarned.toNumber()).to.equal(amount);

      // Verify service revenue updated
      const svc = await program.account.service.fetch(servicePDA);
      expect(svc.totalRevenue.toNumber()).to.equal(amount);
    });

    it("fails to release an already released payment", async () => {
      try {
        await program.methods
          .releasePayment()
          .accounts({
            payment: paymentPDA,
            escrow: escrowPDA,
            payerAgent: agentBPDA,
            receiverAgent: agentAPDA,
            service: servicePDA,
            receiverAuthority: agentAKeypair.publicKey,
            authority: agentBKeypair.publicKey,
          })
          .signers([agentBKeypair])
          .rpc();
        expect.fail("Should have thrown PaymentNotEscrowed");
      } catch (err: any) {
        expect(err.toString()).to.include("PaymentNotEscrowed");
      }
    });

    it("fails when non-payer tries to release", async () => {
      // First create a new payment to test unauthorized release
      const svc = await program.account.service.fetch(servicePDA);
      const [newPmtPDA] = findPaymentPDA(
        agentBPDA,
        servicePDA,
        svc.totalOrders.toNumber()
      );
      const [newEscPDA] = findEscrowPDA(newPmtPDA);

      // Create the payment first
      await program.methods
        .payForService(
          new anchor.BN(0.01 * LAMPORTS_PER_SOL),
          "Test unauthorized release",
          [],
          new anchor.BN(3600)
        )
        .accounts({
          payment: newPmtPDA,
          escrow: newEscPDA,
          payerAgent: agentBPDA,
          receiverAgent: agentAPDA,
          service: servicePDA,
          payerAuthority: agentBKeypair.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([agentBKeypair])
        .rpc();

      // Now try to release with agent A's authority (not the payer)
      try {
        await program.methods
          .releasePayment()
          .accounts({
            payment: newPmtPDA,
            escrow: newEscPDA,
            payerAgent: agentAPDA, // wrong payer agent
            receiverAgent: agentBPDA,
            service: servicePDA,
            receiverAuthority: agentBKeypair.publicKey,
            authority: agentAKeypair.publicKey,
          })
          .signers([agentAKeypair])
          .rpc();
        expect.fail("Should have thrown Unauthorized");
      } catch (err: any) {
        expect(err).to.exist;
      }

      // Store for refund test
      (describe as any)._newPmtPDA = newPmtPDA;
      (describe as any)._newEscPDA = newEscPDA;
    });
  });

  // ================================================================
  // 8. REFUND PAYMENT
  // ================================================================
  describe("refund_payment", () => {
    let refundPaymentPDA: PublicKey;
    let refundEscrowPDA: PublicKey;

    before(() => {
      refundPaymentPDA = (describe as any)._newPmtPDA;
      refundEscrowPDA = (describe as any)._newEscPDA;
    });

    it("payer can refund their own escrowed payment", async () => {
      const payerBalBefore = await provider.connection.getBalance(
        agentBKeypair.publicKey
      );
      const payment = await program.account.payment.fetch(refundPaymentPDA);
      const amount = payment.amount.toNumber();

      await program.methods
        .refundPayment()
        .accounts({
          payment: refundPaymentPDA,
          escrow: refundEscrowPDA,
          payerAgent: agentBPDA,
          payerAuthority: agentBKeypair.publicKey,
          authority: agentBKeypair.publicKey,
        })
        .signers([agentBKeypair])
        .rpc();

      // Verify payment status changed to Refunded
      const paymentAfter = await program.account.payment.fetch(
        refundPaymentPDA
      );
      expect(paymentAfter.status).to.deep.equal({ refunded: {} });
      expect(paymentAfter.completedAt.toNumber()).to.be.greaterThan(0);

      // Verify payer got funds back
      const payerBalAfter = await provider.connection.getBalance(
        agentBKeypair.publicKey
      );
      expect(payerBalAfter - payerBalBefore).to.equal(amount);
    });

    it("fails to refund an already refunded payment", async () => {
      try {
        await program.methods
          .refundPayment()
          .accounts({
            payment: refundPaymentPDA,
            escrow: refundEscrowPDA,
            payerAgent: agentBPDA,
            payerAuthority: agentBKeypair.publicKey,
            authority: agentBKeypair.publicKey,
          })
          .signers([agentBKeypair])
          .rpc();
        expect.fail("Should have thrown PaymentNotEscrowed");
      } catch (err: any) {
        expect(err.toString()).to.include("PaymentNotEscrowed");
      }
    });

    it("non-payer cannot refund before timeout", async () => {
      // Create a fresh payment
      const svc = await program.account.service.fetch(servicePDA);
      const [freshPmtPDA] = findPaymentPDA(
        agentBPDA,
        servicePDA,
        svc.totalOrders.toNumber()
      );
      const [freshEscPDA] = findEscrowPDA(freshPmtPDA);

      await program.methods
        .payForService(
          new anchor.BN(0.01 * LAMPORTS_PER_SOL),
          "Test non-payer refund",
          [],
          new anchor.BN(99999) // long timeout
        )
        .accounts({
          payment: freshPmtPDA,
          escrow: freshEscPDA,
          payerAgent: agentBPDA,
          receiverAgent: agentAPDA,
          service: servicePDA,
          payerAuthority: agentBKeypair.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([agentBKeypair])
        .rpc();

      // Agent A (not the payer) tries to refund before timeout
      try {
        await program.methods
          .refundPayment()
          .accounts({
            payment: freshPmtPDA,
            escrow: freshEscPDA,
            payerAgent: agentBPDA,
            payerAuthority: agentBKeypair.publicKey,
            authority: agentAKeypair.publicKey, // not the payer
          })
          .signers([agentAKeypair])
          .rpc();
        expect.fail("Should have thrown RefundNotAllowed");
      } catch (err: any) {
        expect(err.toString()).to.include("RefundNotAllowed");
      }
    });
  });

  // ================================================================
  // 9. CREATE STREAM
  // ================================================================
  describe("create_stream", () => {
    const ratePerSecond = new anchor.BN(1000); // 1000 lamports/sec
    const maxDuration = new anchor.BN(3600); // 1 hour
    const depositAmount = new anchor.BN(100_000); // 100k lamports (> 1000 * 60)
    let streamPDA: PublicKey;
    let streamVaultPDA: PublicKey;

    it("creates a streaming payment from agent B to agent A", async () => {
      const [sPDA] = findStreamPDA(agentBPDA, agentAPDA);
      streamPDA = sPDA;
      const [svPDA] = findStreamVaultPDA(streamPDA);
      streamVaultPDA = svPDA;

      await program.methods
        .createStream(ratePerSecond, maxDuration, depositAmount)
        .accounts({
          stream: streamPDA,
          streamVault: streamVaultPDA,
          payerAgent: agentBPDA,
          receiverAgent: agentAPDA,
          payerAuthority: agentBKeypair.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([agentBKeypair])
        .rpc();

      const stream = await program.account.stream.fetch(streamPDA);
      expect(stream.payer.toBase58()).to.equal(agentBPDA.toBase58());
      expect(stream.receiver.toBase58()).to.equal(agentAPDA.toBase58());
      expect(stream.ratePerSecond.toNumber()).to.equal(1000);
      expect(stream.deposited.toNumber()).to.equal(100_000);
      expect(stream.withdrawn.toNumber()).to.equal(0);
      expect(stream.isActive).to.be.true;
      expect(stream.startedAt.toNumber()).to.be.greaterThan(0);
      expect(stream.lastWithdrawnAt.toNumber()).to.equal(
        stream.startedAt.toNumber()
      );

      // Verify vault received the deposit
      const vaultBal = await provider.connection.getBalance(streamVaultPDA);
      expect(vaultBal).to.be.gte(depositAmount.toNumber());

      // Store for withdraw tests
      (describe as any)._streamPDA = streamPDA;
      (describe as any)._streamVaultPDA = streamVaultPDA;
    });

    it("fails with zero rate", async () => {
      const freshPayerKp = await createFundedKeypair();
      const freshPayerAgentPDA = await registerAgentHelper(
        freshPayerKp,
        "ZeroRate"
      );
      const [sPDA] = findStreamPDA(freshPayerAgentPDA, agentAPDA);
      const [svPDA] = findStreamVaultPDA(sPDA);

      try {
        await program.methods
          .createStream(
            new anchor.BN(0),
            new anchor.BN(3600),
            new anchor.BN(100_000)
          )
          .accounts({
            stream: sPDA,
            streamVault: svPDA,
            payerAgent: freshPayerAgentPDA,
            receiverAgent: agentAPDA,
            payerAuthority: freshPayerKp.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([freshPayerKp])
          .rpc();
        expect.fail("Should have thrown ZeroAmount");
      } catch (err: any) {
        expect(err.toString()).to.include("ZeroAmount");
      }
    });

    it("fails with insufficient deposit (less than rate * 60)", async () => {
      const freshPayerKp = await createFundedKeypair();
      const freshPayerAgentPDA = await registerAgentHelper(
        freshPayerKp,
        "LowDeposit"
      );
      const [sPDA] = findStreamPDA(freshPayerAgentPDA, agentAPDA);
      const [svPDA] = findStreamVaultPDA(sPDA);

      try {
        await program.methods
          .createStream(
            new anchor.BN(1000), // 1000 lamports/sec
            new anchor.BN(3600),
            new anchor.BN(59_000) // less than 1000 * 60 = 60_000
          )
          .accounts({
            stream: sPDA,
            streamVault: svPDA,
            payerAgent: freshPayerAgentPDA,
            receiverAgent: agentAPDA,
            payerAuthority: freshPayerKp.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([freshPayerKp])
          .rpc();
        expect.fail("Should have thrown InsufficientDeposit");
      } catch (err: any) {
        expect(err.toString()).to.include("InsufficientDeposit");
      }
    });
  });

  // ================================================================
  // 10. WITHDRAW STREAM
  // ================================================================
  describe("withdraw_stream", () => {
    let streamPDA: PublicKey;
    let streamVaultPDA: PublicKey;

    before(() => {
      streamPDA = (describe as any)._streamPDA;
      streamVaultPDA = (describe as any)._streamVaultPDA;
    });

    it("receiver withdraws accumulated streaming payment", async () => {
      // Wait a bit for some funds to accumulate
      await new Promise((resolve) => setTimeout(resolve, 2000));

      const receiverBalBefore = await provider.connection.getBalance(
        agentAKeypair.publicKey
      );

      await program.methods
        .withdrawStream()
        .accounts({
          stream: streamPDA,
          streamVault: streamVaultPDA,
          receiverAgent: agentAPDA,
          receiverAuthority: agentAKeypair.publicKey,
          payerAuthority: agentBKeypair.publicKey,
          authority: agentAKeypair.publicKey,
        })
        .signers([agentAKeypair])
        .rpc();

      const stream = await program.account.stream.fetch(streamPDA);
      expect(stream.withdrawn.toNumber()).to.be.greaterThan(0);

      // Verify receiver got funds
      const receiverBalAfter = await provider.connection.getBalance(
        agentAKeypair.publicKey
      );
      expect(receiverBalAfter).to.be.greaterThan(receiverBalBefore);

      // Verify receiver agent stats updated
      const receiverAgent = await program.account.agent.fetch(agentAPDA);
      expect(receiverAgent.totalEarned.toNumber()).to.be.greaterThan(0);
    });

    it("can withdraw multiple times as time passes", async () => {
      await new Promise((resolve) => setTimeout(resolve, 2000));

      const streamBefore = await program.account.stream.fetch(streamPDA);
      const withdrawnBefore = streamBefore.withdrawn.toNumber();

      await program.methods
        .withdrawStream()
        .accounts({
          stream: streamPDA,
          streamVault: streamVaultPDA,
          receiverAgent: agentAPDA,
          receiverAuthority: agentAKeypair.publicKey,
          payerAuthority: agentBKeypair.publicKey,
          authority: agentAKeypair.publicKey,
        })
        .signers([agentAKeypair])
        .rpc();

      const streamAfter = await program.account.stream.fetch(streamPDA);
      expect(streamAfter.withdrawn.toNumber()).to.be.greaterThan(
        withdrawnBefore
      );
    });
  });

  // ================================================================
  // FULL ESCROW FLOW: PAY -> RELEASE
  // ================================================================
  describe("full escrow flow: pay -> release", () => {
    let payerKp: Keypair;
    let receiverKp: Keypair;
    let payerAgentPDA: PublicKey;
    let receiverAgentPDA: PublicKey;
    let svcPDA: PublicKey;
    let pmtPDA: PublicKey;
    let escPDA: PublicKey;
    const flowSvcId = "full-flow-svc";
    const payAmount = new anchor.BN(0.1 * LAMPORTS_PER_SOL);

    before(async () => {
      payerKp = await createFundedKeypair();
      receiverKp = await createFundedKeypair();
      payerAgentPDA = await registerAgentHelper(payerKp, "FlowPayer");
      receiverAgentPDA = await registerAgentHelper(receiverKp, "FlowReceiver");

      // Receiver creates service
      const [sPDA] = findServicePDA(receiverAgentPDA, flowSvcId);
      svcPDA = sPDA;
      await program.methods
        .createService(
          flowSvcId,
          "Full Flow Service",
          "End-to-end test",
          payAmount,
          { fixed: {} },
          ["e2e"]
        )
        .accounts({
          service: svcPDA,
          agent: receiverAgentPDA,
          authority: receiverKp.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([receiverKp])
        .rpc();
    });

    it("executes complete pay -> release flow", async () => {
      const svc = await program.account.service.fetch(svcPDA);
      const [pPDA] = findPaymentPDA(
        payerAgentPDA,
        svcPDA,
        svc.totalOrders.toNumber()
      );
      pmtPDA = pPDA;
      const [ePDA] = findEscrowPDA(pmtPDA);
      escPDA = ePDA;

      // Step 1: Pay
      const payerBalBefore = await provider.connection.getBalance(
        payerKp.publicKey
      );
      const receiverBalBefore = await provider.connection.getBalance(
        receiverKp.publicKey
      );

      await program.methods
        .payForService(
          payAmount,
          "Full flow test payment",
          ["condition-a"],
          new anchor.BN(3600)
        )
        .accounts({
          payment: pmtPDA,
          escrow: escPDA,
          payerAgent: payerAgentPDA,
          receiverAgent: receiverAgentPDA,
          service: svcPDA,
          payerAuthority: payerKp.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([payerKp])
        .rpc();

      let payment = await program.account.payment.fetch(pmtPDA);
      expect(payment.status).to.deep.equal({ escrowed: {} });

      // Step 2: Release
      await program.methods
        .releasePayment()
        .accounts({
          payment: pmtPDA,
          escrow: escPDA,
          payerAgent: payerAgentPDA,
          receiverAgent: receiverAgentPDA,
          service: svcPDA,
          receiverAuthority: receiverKp.publicKey,
          authority: payerKp.publicKey,
        })
        .signers([payerKp])
        .rpc();

      payment = await program.account.payment.fetch(pmtPDA);
      expect(payment.status).to.deep.equal({ released: {} });

      // Verify receiver earned funds
      const receiverBalAfter = await provider.connection.getBalance(
        receiverKp.publicKey
      );
      expect(receiverBalAfter - receiverBalBefore).to.equal(
        payAmount.toNumber()
      );

      // Verify agent stats
      const payerAgent = await program.account.agent.fetch(payerAgentPDA);
      expect(payerAgent.servicesRequested.toNumber()).to.equal(1);
      expect(payerAgent.totalSpent.toNumber()).to.equal(payAmount.toNumber());

      const receiverAgent = await program.account.agent.fetch(
        receiverAgentPDA
      );
      expect(receiverAgent.servicesCompleted.toNumber()).to.equal(1);
      expect(receiverAgent.totalEarned.toNumber()).to.equal(
        payAmount.toNumber()
      );

      // Verify service stats
      const svcAfter = await program.account.service.fetch(svcPDA);
      expect(svcAfter.totalOrders.toNumber()).to.equal(1);
      expect(svcAfter.totalRevenue.toNumber()).to.equal(payAmount.toNumber());
    });
  });

  // ================================================================
  // FULL ESCROW FLOW: PAY -> REFUND (payer-initiated)
  // ================================================================
  describe("full escrow flow: pay -> refund (payer-initiated)", () => {
    let payerKp: Keypair;
    let receiverKp: Keypair;
    let payerAgentPDA: PublicKey;
    let receiverAgentPDA: PublicKey;
    let svcPDA: PublicKey;
    const refundSvcId = "refund-flow-svc";
    const payAmount = new anchor.BN(0.05 * LAMPORTS_PER_SOL);

    before(async () => {
      payerKp = await createFundedKeypair();
      receiverKp = await createFundedKeypair();
      payerAgentPDA = await registerAgentHelper(payerKp, "RefundPayer");
      receiverAgentPDA = await registerAgentHelper(
        receiverKp,
        "RefundReceiver"
      );

      const [sPDA] = findServicePDA(receiverAgentPDA, refundSvcId);
      svcPDA = sPDA;
      await program.methods
        .createService(
          refundSvcId,
          "Refund Flow Service",
          "Refund test",
          payAmount,
          { fixed: {} },
          ["refund"]
        )
        .accounts({
          service: svcPDA,
          agent: receiverAgentPDA,
          authority: receiverKp.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([receiverKp])
        .rpc();
    });

    it("executes complete pay -> refund flow", async () => {
      const svc = await program.account.service.fetch(svcPDA);
      const [pmtPDA] = findPaymentPDA(
        payerAgentPDA,
        svcPDA,
        svc.totalOrders.toNumber()
      );
      const [escPDA] = findEscrowPDA(pmtPDA);

      // Step 1: Pay
      const payerBalBefore = await provider.connection.getBalance(
        payerKp.publicKey
      );

      await program.methods
        .payForService(
          payAmount,
          "Payment that will be refunded",
          [],
          new anchor.BN(3600)
        )
        .accounts({
          payment: pmtPDA,
          escrow: escPDA,
          payerAgent: payerAgentPDA,
          receiverAgent: receiverAgentPDA,
          service: svcPDA,
          payerAuthority: payerKp.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([payerKp])
        .rpc();

      let payment = await program.account.payment.fetch(pmtPDA);
      expect(payment.status).to.deep.equal({ escrowed: {} });

      const payerBalAfterPay = await provider.connection.getBalance(
        payerKp.publicKey
      );
      // Payer should have less SOL (payment + tx fees)
      expect(payerBalAfterPay).to.be.lessThan(payerBalBefore);

      // Step 2: Refund (payer-initiated)
      await program.methods
        .refundPayment()
        .accounts({
          payment: pmtPDA,
          escrow: escPDA,
          payerAgent: payerAgentPDA,
          payerAuthority: payerKp.publicKey,
          authority: payerKp.publicKey,
        })
        .signers([payerKp])
        .rpc();

      payment = await program.account.payment.fetch(pmtPDA);
      expect(payment.status).to.deep.equal({ refunded: {} });

      // Payer gets the escrowed amount back
      const payerBalAfterRefund = await provider.connection.getBalance(
        payerKp.publicKey
      );
      // Balance after refund should be higher than after pay (got money back)
      expect(payerBalAfterRefund).to.be.greaterThan(payerBalAfterPay);
    });
  });

  // ================================================================
  // STREAMING PAYMENT FLOW: CREATE -> WITHDRAW -> CLOSE
  // ================================================================
  describe("streaming payment flow: create -> withdraw -> auto-close", () => {
    let payerKp: Keypair;
    let receiverKp: Keypair;
    let payerAgentPDA: PublicKey;
    let receiverAgentPDA: PublicKey;
    let streamPDA: PublicKey;
    let streamVaultPDA: PublicKey;

    // Use a high rate and small deposit so the stream exhausts quickly
    const ratePerSecond = new anchor.BN(50_000); // 50k lamports/sec
    const maxDuration = new anchor.BN(3600);
    // deposit = rate * 60 exactly (minimum), stream will be exhausted in 2 seconds
    const depositAmount = new anchor.BN(50_000 * 60); // 3M lamports

    before(async () => {
      payerKp = await createFundedKeypair();
      receiverKp = await createFundedKeypair();
      payerAgentPDA = await registerAgentHelper(payerKp, "StreamPayer");
      receiverAgentPDA = await registerAgentHelper(
        receiverKp,
        "StreamReceiver"
      );
    });

    it("creates stream, withdraws, and verifies accumulation", async () => {
      const [sPDA] = findStreamPDA(payerAgentPDA, receiverAgentPDA);
      streamPDA = sPDA;
      const [svPDA] = findStreamVaultPDA(streamPDA);
      streamVaultPDA = svPDA;

      // Step 1: Create stream
      await program.methods
        .createStream(ratePerSecond, maxDuration, depositAmount)
        .accounts({
          stream: streamPDA,
          streamVault: streamVaultPDA,
          payerAgent: payerAgentPDA,
          receiverAgent: receiverAgentPDA,
          payerAuthority: payerKp.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([payerKp])
        .rpc();

      let stream = await program.account.stream.fetch(streamPDA);
      expect(stream.isActive).to.be.true;
      expect(stream.deposited.toNumber()).to.equal(depositAmount.toNumber());
      expect(stream.withdrawn.toNumber()).to.equal(0);

      // Step 2: Wait and withdraw
      await new Promise((resolve) => setTimeout(resolve, 2000));

      const receiverBalBefore = await provider.connection.getBalance(
        receiverKp.publicKey
      );

      await program.methods
        .withdrawStream()
        .accounts({
          stream: streamPDA,
          streamVault: streamVaultPDA,
          receiverAgent: receiverAgentPDA,
          receiverAuthority: receiverKp.publicKey,
          payerAuthority: payerKp.publicKey,
          authority: receiverKp.publicKey,
        })
        .signers([receiverKp])
        .rpc();

      stream = await program.account.stream.fetch(streamPDA);
      expect(stream.withdrawn.toNumber()).to.be.greaterThan(0);

      const receiverBalAfter = await provider.connection.getBalance(
        receiverKp.publicKey
      );
      expect(receiverBalAfter).to.be.greaterThan(receiverBalBefore);
    });
  });

  // ================================================================
  // REPUTATION CALCULATION WITH FEEDBACK AND STAKING COMBINED
  // ================================================================
  describe("reputation score calculation", () => {
    let agentKp: Keypair;
    let agentPDA: PublicKey;

    before(async () => {
      agentKp = await createFundedKeypair(20);
      agentPDA = await registerAgentHelper(agentKp, "ReputationTest");
    });

    it("starts at 0 reputation", async () => {
      const agent = await program.account.agent.fetch(agentPDA);
      expect(agent.reputationScore.toNumber()).to.equal(0);
    });

    it("staking 1 SOL gives reputation of 50", async () => {
      const [vaultPDA] = findVaultPDA(agentPDA);
      await program.methods
        .stakeReputation(new anchor.BN(1 * LAMPORTS_PER_SOL))
        .accounts({
          agent: agentPDA,
          vault: vaultPDA,
          authority: agentKp.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([agentKp])
        .rpc();

      const agent = await program.account.agent.fetch(agentPDA);
      // log2(1.0) * 10 + 50 = 50
      expect(agent.reputationScore.toNumber()).to.equal(50);
    });

    it("receiving feedback adds to reputation", async () => {
      // Create a different agent to submit feedback
      const feedbackerKp = await createFundedKeypair();
      const feedbackerPDA = await registerAgentHelper(
        feedbackerKp,
        "Feedbacker1"
      );
      const [feedbackPDA] = findFeedbackPDA(feedbackerPDA, agentPDA);

      await program.methods
        .submitFeedback(5, "Great work!")
        .accounts({
          feedback: feedbackPDA,
          fromAgent: feedbackerPDA,
          toAgent: agentPDA,
          authority: feedbackerKp.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([feedbackerKp])
        .rpc();

      const agent = await program.account.agent.fetch(agentPDA);
      // base_rep = 50 (from 1 SOL), feedback_bonus = 1 * 2 = 2, completion = 0
      expect(agent.reputationScore.toNumber()).to.equal(52);
    });

    it("additional staking recalculates reputation including feedback bonus", async () => {
      const [vaultPDA] = findVaultPDA(agentPDA);
      // Stake 1 more SOL (total 2 SOL)
      await program.methods
        .stakeReputation(new anchor.BN(1 * LAMPORTS_PER_SOL))
        .accounts({
          agent: agentPDA,
          vault: vaultPDA,
          authority: agentKp.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([agentKp])
        .rpc();

      const agent = await program.account.agent.fetch(agentPDA);
      // log2(2.0) * 10 + 50 = 10 + 50 = 60; feedback_bonus = 1 * 2 = 2; total = 62
      expect(agent.reputationScore.toNumber()).to.equal(62);
    });
  });

  // ================================================================
  // MARKETPLACE SERVICE DISCOVERY
  // ================================================================
  describe("marketplace service discovery", () => {
    it("can fetch all services from the program", async () => {
      const allServices = await program.account.service.all();
      expect(allServices.length).to.be.greaterThan(0);

      // Every service should have required fields
      for (const svc of allServices) {
        expect(svc.account.title.length).to.be.greaterThan(0);
        expect(svc.account.isActive).to.be.true;
        expect(svc.account.createdAt.toNumber()).to.be.greaterThan(0);
      }
    });

    it("can filter services by provider (agent A)", async () => {
      const allServices = await program.account.service.all([
        {
          memcmp: {
            offset: 8, // discriminator
            bytes: agentAPDA.toBase58(),
          },
        },
      ]);
      expect(allServices.length).to.be.greaterThan(0);
      for (const svc of allServices) {
        expect(svc.account.provider.toBase58()).to.equal(
          agentAPDA.toBase58()
        );
      }
    });

    it("can fetch all registered agents", async () => {
      const allAgents = await program.account.agent.all();
      expect(allAgents.length).to.be.greaterThanOrEqual(2);

      // Every agent should be active
      for (const a of allAgents) {
        expect(a.account.isActive).to.be.true;
        expect(a.account.name.length).to.be.greaterThan(0);
      }
    });
  });

  // ================================================================
  // EDGE CASES & ADDITIONAL VALIDATIONS
  // ================================================================
  describe("edge cases", () => {
    it("allows registering agent with empty capabilities list", async () => {
      const kp = await createFundedKeypair();
      const [pda] = findAgentPDA(kp.publicKey);

      await program.methods
        .registerAgent("MinimalAgent", "Just exists", [], "https://min.ai")
        .accounts({
          agent: pda,
          authority: kp.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([kp])
        .rpc();

      const agent = await program.account.agent.fetch(pda);
      expect(agent.capabilities).to.deep.equal([]);
      expect(agent.name).to.equal("MinimalAgent");
    });

    it("allows registering agent with exactly 32-char name", async () => {
      const kp = await createFundedKeypair();
      const [pda] = findAgentPDA(kp.publicKey);
      const name32 = "A".repeat(32);

      await program.methods
        .registerAgent(name32, "Boundary test", ["test"], "https://a.ai")
        .accounts({
          agent: pda,
          authority: kp.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([kp])
        .rpc();

      const agent = await program.account.agent.fetch(pda);
      expect(agent.name).to.equal(name32);
      expect(agent.name.length).to.equal(32);
    });

    it("allows creating service with exactly 5 tags", async () => {
      const kp = await createFundedKeypair();
      const agentPDA = await registerAgentHelper(kp, "FiveTagsAgent");
      const [svcPDA] = findServicePDA(agentPDA, "five-tags");

      await program.methods
        .createService(
          "five-tags",
          "Five Tags Service",
          "Has exactly five tags",
          new anchor.BN(100),
          { fixed: {} },
          ["tag1", "tag2", "tag3", "tag4", "tag5"]
        )
        .accounts({
          service: svcPDA,
          agent: agentPDA,
          authority: kp.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([kp])
        .rpc();

      const svc = await program.account.service.fetch(svcPDA);
      expect(svc.tags.length).to.equal(5);
    });

    it("allows creating service with empty tags", async () => {
      const kp = await createFundedKeypair();
      const agentPDA = await registerAgentHelper(kp, "NoTagsAgent");
      const [svcPDA] = findServicePDA(agentPDA, "no-tags");

      await program.methods
        .createService(
          "no-tags",
          "No Tags Service",
          "Has no tags",
          new anchor.BN(100),
          { fixed: {} },
          []
        )
        .accounts({
          service: svcPDA,
          agent: agentPDA,
          authority: kp.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([kp])
        .rpc();

      const svc = await program.account.service.fetch(svcPDA);
      expect(svc.tags.length).to.equal(0);
    });

    it("allows submitting feedback with minimum valid rating (1)", async () => {
      const fromKp = await createFundedKeypair();
      const toKp = await createFundedKeypair();
      const fromPDA = await registerAgentHelper(fromKp, "MinRater");
      const toPDA = await registerAgentHelper(toKp, "MinRated");
      const [feedbackPDA] = findFeedbackPDA(fromPDA, toPDA);

      await program.methods
        .submitFeedback(1, "Minimum rating")
        .accounts({
          feedback: feedbackPDA,
          fromAgent: fromPDA,
          toAgent: toPDA,
          authority: fromKp.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([fromKp])
        .rpc();

      const feedback = await program.account.feedback.fetch(feedbackPDA);
      expect(feedback.rating).to.equal(1);
    });

    it("allows submitting feedback with maximum valid rating (5)", async () => {
      const fromKp = await createFundedKeypair();
      const toKp = await createFundedKeypair();
      const fromPDA = await registerAgentHelper(fromKp, "MaxRater");
      const toPDA = await registerAgentHelper(toKp, "MaxRated");
      const [feedbackPDA] = findFeedbackPDA(fromPDA, toPDA);

      await program.methods
        .submitFeedback(5, "Maximum rating")
        .accounts({
          feedback: feedbackPDA,
          fromAgent: fromPDA,
          toAgent: toPDA,
          authority: fromKp.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([fromKp])
        .rpc();

      const feedback = await program.account.feedback.fetch(feedbackPDA);
      expect(feedback.rating).to.equal(5);
    });

    it("stream deposit exactly at minimum (rate * 60) succeeds", async () => {
      const payerKp = await createFundedKeypair();
      const receiverKp = await createFundedKeypair();
      const payerPDA = await registerAgentHelper(payerKp, "ExactDepPayer");
      const receiverPDA = await registerAgentHelper(
        receiverKp,
        "ExactDepRecvr"
      );
      const [sPDA] = findStreamPDA(payerPDA, receiverPDA);
      const [svPDA] = findStreamVaultPDA(sPDA);

      const rate = 1000;
      const exactMinDeposit = rate * 60; // exactly rate * 60

      await program.methods
        .createStream(
          new anchor.BN(rate),
          new anchor.BN(3600),
          new anchor.BN(exactMinDeposit)
        )
        .accounts({
          stream: sPDA,
          streamVault: svPDA,
          payerAgent: payerPDA,
          receiverAgent: receiverPDA,
          payerAuthority: payerKp.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([payerKp])
        .rpc();

      const stream = await program.account.stream.fetch(sPDA);
      expect(stream.deposited.toNumber()).to.equal(exactMinDeposit);
      expect(stream.isActive).to.be.true;
    });
  });
});
